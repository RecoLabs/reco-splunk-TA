{"basic_builder": {"appname": "TA-reco", "friendly_name": "Reco", "version": "1.0.1", "author": "gal@reco.ai", "description": "Reco is an full lifecycle SaaS security solution. It empowers organizations to discover their SaaS applications, identities, and data.", "theme": "#3c6188", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAABZRJREFUWEftmGlslEUYx3+zR7vbMwXaZaEXEI5iKSDIUYQgqcjRSilQiRjABokiEI3EaBA/oCKikVAOkSOcWg7LIRQJIYAQKQQtUHpSbGltaSm9j+1uu7uveV8gQbpll5JaP/h8231n5vnNMzPP/5kRIAmAgaOPLXTXqN612RhglySt/N+/YGUSJKuszd/euBJXIPsTMtBzo1MSBcSAZAShfQjZ0UACbBKYQLpqR/NeVurkayJi9NFJdlQbBYRIoO5oCEfjCzBpNaqzaRemxIjw0cd2A9MBr8cbD+zvS2x0IF27uJORXcuOvX92EK+QhJCKJZs9WgY6B4wEdI96C+zpQVxMEK9NFnjY0ikyv8z23bfIzK1j1rQgvLwcbzNTk5Wyu2aam+1cu1FNVm4tdrvkykQqkcSKNoF6h3oxJ74X8VHVUJFMg98H/HConCMpxcyKDW4TSPbs7qaiu0GPyWTlekYV+w8V0dBofTKUoEaSRGKbQN5eWl4aa+DNWToCfW9xo3gQG3eUcDW9GkOADo1aOZytzN1dTXeDjpAgT8L6+RIe5kPysWKOnyyhuqa5bShnQHJP2fGMmCDiYoLZuiuP/YeLXAm90katFhj8dcyd3YtxYwL4cm0WV9IqMZttjsdwBUjuOS4ygGVLwvjki3TSM6pdBlJyioAAfx1rVw0j7Xo1+w/d5q8SU+cBPfS8cF4fRr7gz4YtN7maXtX5QOMiDXz0/kBWr83k/MXyzgeKCPfj8+URfLM++38gh8vxn4vQq1MCSZjTmzWJ2Vy8fK/z99D6r4aj1QrWb7lJZk5t5wHJyXFKlJG3E/px4EghKafuUFFpaT9Qj+56RbemRwdx4HAhm7bnuZQYdTo1ffv4EB7mS+yUnuTfbmRnUj75BQ20WO3tA/L1cSNqvIH5M70J9CvkdmVv1my8Q05ePUMG+SFrlkMtc1MhT6R3qDd+fm6UljUpgpyZU9O2bChp3Ym4+nfTMWtaMG/FC9QN56nVTOS7PTVcSasifnoIXl6aVjw2m4QQAl8fjbI0BYWNnDpTSnmFGfnbE80ZkNx51PBuLF0YTN8QiYxb7ny88poy5oC+vri5qVqNb7HYqW9soaXFjqnRSkWVhbr6FiRXyiFXgDw8NLwywcg7CX3ZsO0mP58odrqHdO5qBg7wIXZqIL9druD0uTLn0XFlyR56bo/ay8XdZ8sjMFvsLP3wd+Qq0mmUXIlQe8sPHx8tk6N6smzxABKWXCInt67t0/Vw5h0JJNdBPYwe/Lg1kjO/lrFucy41dS3PvqnbGyG5n4+3lgVz+zDxJSPzFqVyt9zcuUBqlcDYXc/OTaPYlVTAsZMl1NQ+Y02t16uVGS5a0I/EzTlK6n8ak1PD6k8HYwjQk5Vbxy+n75B9s5amJgd1tSt7aNjgLixKCCa8v5q0TBUrVqVTWWVxfmIeUMvZfNu6EVgsNjw9NZRXWNidVMAf1x2Usc6AjIb7OjY/To3GdIk6zXi27ath7/7bWNvSo8fCp9epOXV4Aj8dLUKrVTF+jIHvd+Ypy9fKnAGFBnsyOy6E+KlatOZ06tXPczDFxIYtuUomdsVkkT2w80Vu5TfQ2GAlKNCDXUn5nL1w11F3OWwrRXhkyj4kezTg+WgrD72aoRFdmBRlVO72VdXN7EsufJqrMRqN4PWZoQwb0hVJkkjPrFYyd1Gxo6uQKBVCmiHCI4+/IQRfS3YMjp5hPD00yk1U1qR7FW3UMk7C1SvEC61GUFLaRKPJ0ZVamEG6lJEaPUF5Hxo69sRhq80eKUn4Aa1l3JX1aV8b+bXMLCFlSoi1manRSQpQ/xEHQzUq/WIhmAh0vf+Q1fGmEsKiVonsZpt9jwxzX2MfPOnJP8KGHgrWummNdiH+8TTTUWhCuJXdSJ2Y++j4fwN8Xu7RdO0fegAAAABJRU5ErkJggg==", "visible": true, "tab_version": "4.3.0", "tab_build_no": "0", "build_no": 2}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "recoAlerts", "interval": "30", "use_external_validation": true, "streaming_mode_xml": true, "name": "reco_alerts", "title": "Reco Alerts", "description": "", "type": "customized", "parameters": [{"name": "limit", "label": "Limit", "help_string": "", "required": false, "format_type": "text", "default_value": "1000", "placeholder": "", "type": "text", "value": "1000"}, {"name": "alert_status", "label": "Alert Status", "help_string": "", "required": false, "possible_values": [{"value": "1", "label": "New"}, {"value": "2", "label": "In Progress"}, {"value": "3", "label": "Closed"}], "format_type": "dropdownlist", "default_value": "1", "placeholder": "", "type": "dropdownlist", "value": "1"}], "data_inputs_options": [{"type": "customized_var", "name": "limit", "title": "Limit", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "1000", "placeholder": ""}, {"type": "customized_var", "name": "alert_status", "title": "Alert Status", "description": "", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "1", "label": "New"}, {"value": "2", "label": "In Progress"}, {"value": "3", "label": "Closed"}], "format_type": "dropdownlist", "default_value": "1", "placeholder": ""}], "code": "import json\nimport base64\nfrom datetime import datetime\n\n# Required configurations for Reco API\nRECO_API_TIMEOUT_IN_SECONDS = 30\nRECO_ACTIVE_ALERTS_VIEW = \"ALERT_VIEW_WITH_SHARED_STATUS\"\nCREATED_AT_FIELD = \"created_at\"\nFILTER_RELATIONSHIP_AND = \"AND\"\nDEMISTO_OCCURRED_FORMAT = \"%Y-%m-%dT%H:%M:%SZ\"\n\ndef validate_input(helper, definition):\n    \"\"\"Validate the input configurations.\"\"\"\n    pass\n\ndef collect_events(helper, ew):\n    \"\"\"Fetch incidents and alerts from Reco API and send them to Splunk.\"\"\"\n    max_fetch = helper.get_arg('limit')\n    status = helper.get_arg('alert_status')\n    source = helper.get_arg('source')  # Ensure 'source' is retrieved if applicable\n    last_run = helper.get_check_point(\"last_run\") or {}\n    global_tenant_url = helper.get_global_setting(\"tenant_url\")\n    global_api_key = helper.get_global_setting(\"api_key\")\n\n    helper.log_info(f\"Starting collection of events from Reco with max_fetch={max_fetch}, status={status}, source={source}\")\n\n    # Convert last_run time to a datetime object if present\n    after = datetime.strptime(last_run.get(\"lastRun\", \"\"), DEMISTO_OCCURRED_FORMAT) if \"lastRun\" in last_run else None\n    if after:\n        helper.log_info(f\"Last run time: {after}\")\n\n    alerts = []  # Initialize the alerts variable to avoid UnboundLocalError\n\n    # Fetch alerts\n    try:\n        alerts = fetch_reco_alerts(helper, global_tenant_url, global_api_key, max_fetch, status, source, after)\n        helper.log_info(f\"Fetched {len(alerts)} alerts.\")\n        send_events(alerts, helper, ew)\n    except Exception as e:\n        helper.log_error(f\"Error fetching alerts: {e}\")\n\n    helper.save_check_point(\"last_run\", {\"lastRun\": datetime.now().strftime(DEMISTO_OCCURRED_FORMAT)})\n    helper.log_info(f\"Checkpoint updated with last run time\")\n\ndef fetch_reco_alerts(helper, tenant_url, api_key, max_fetch, status, source, after):\n    \"\"\"Retrieve alerts from Reco API and get additional details for each alert.\"\"\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    params = create_params(RECO_ACTIVE_ALERTS_VIEW, max_fetch, status, source, after)\n\n    helper.log_info(\"Sending request to Reco API for alert IDs.\")\n    response = helper.send_http_request(\n        url=f\"{tenant_url}/api/v1/policy-subsystem/alert-inbox/table\",\n        method=\"PUT\",\n        payload=json.dumps(params),\n        headers=headers,\n        timeout=RECO_API_TIMEOUT_IN_SECONDS,\n    )\n\n    alerts = parse_response(response)\n    detailed_alerts = []\n\n    # Fetch additional details for each alert\n    helper.log_info(\"Fetching detailed information for each alert.\")\n    for alert in alerts:\n        alert_id = base64.b64decode(alert.get(\"id\")).decode(\"utf-8\")\n        if alert_id:\n            single_alert = get_single_alert(helper, tenant_url, api_key, alert_id)\n            if \"aggregationRulesToKeys\" in single_alert:\n                single_alert.pop(\"aggregationRulesToKeys\")\n            violations = single_alert[\"policyViolations\"]\n            for violation in violations:\n                violation_data = json.loads(base64.b64decode(violation[\"jsonData\"]))\n                if \"violation\" in violation_data:\n                    violation_data.pop(\"violation\")\n                violation[\"jsonData\"] = violation_data\n            single_alert[\"policyViolations\"] = json.loads(json.dumps(single_alert[\"policyViolations\"]))\n            detailed_alerts.append(single_alert)\n            helper.log_info(f\"Fetched detailed data for alert ID: {alert_id}\")\n        else:\n            helper.log_warning(\"Alert ID missing in response.\")\n\n    return detailed_alerts\n\ndef get_single_alert(helper, tenant_url, api_key, alert_id):\n    \"\"\"Fetch a single alert's detailed information from Reco API.\"\"\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    response = helper.send_http_request(\n        url=f\"{tenant_url}/api/v1/policy-subsystem/alert-inbox/{alert_id}\",\n        method=\"GET\",\n        headers=headers,\n        timeout=RECO_API_TIMEOUT_IN_SECONDS,\n    )\n\n    if response.status_code != 200:\n        helper.log_error(f\"Failed to retrieve alert {alert_id}, status code: {response.status_code}\")\n        return {}\n\n    alert_details = response.json().get(\"alert\", {})\n    return alert_details\n\ndef create_params(view_name, max_fetch, status, source, after):\n    \"\"\"Create request parameters for Reco API.\"\"\"\n    filters = {\"relationship\": FILTER_RELATIONSHIP_AND, \"filters\": {\"filters\": []}}\n    if status:\n        filters[\"filters\"][\"filters\"].append({\"field\": \"status\", \"stringEquals\": {\"value\": status}})\n    if source:\n        filters[\"filters\"][\"filters\"].append({\"field\": \"data_source\", \"stringEquals\": {\"value\": source}})\n    if after:\n        filters[\"filters\"][\"filters\"].append(\n            {\"field\": CREATED_AT_FIELD, \"after\": {\"value\": after.strftime(DEMISTO_OCCURRED_FORMAT)}})\n\n    return {\n        \"getTableRequest\": {\n            \"tableName\": view_name,\n            \"pageSize\": max_fetch,\n            \"fieldFilters\": filters,\n            \"fieldSorts\": {\n                \"sorts\": [{\"sortBy\": \"updated_at\", \"sortDirection\": \"SORT_DIRECTION_ASC\"}]\n            }\n        }\n    }\n\ndef parse_response(response):\n    \"\"\"Parse Reco API response.\"\"\"\n    if response.status_code != 200:\n        raise ValueError(f\"Failed to retrieve data, status code: {response.status_code}\")\n    response_data = response.json().get(\"getTableResponse\", {}).get(\"data\", {}).get(\"rows\", [])\n    return [parse_table_row_to_dict(row.get(\"cells\", [])) for row in response_data]\n\ndef parse_table_row_to_dict(alert):\n    \"\"\"Parse a row of alert data into a dictionary format.\"\"\"\n    alert_as_dict = {}\n    for obj in alert:\n        key = obj.get(\"key\")\n        value = obj.get(\"value\")\n        if key and value:\n            alert_as_dict[key] = base64.b64decode(value).decode(\"utf-8\").replace('\"', \"\")\n    return alert_as_dict\n\ndef send_events(entities, helper, ew):\n    \"\"\"Send parsed incidents or alerts as events to Splunk.\"\"\"\n    for entity in entities:\n        event = helper.new_event(data=json.dumps(entity), source=helper.get_input_type(), sourcetype=helper.get_sourcetype(), index=helper.get_output_index())\n        ew.write_event(event)\n        helper.save_check_point(\"alert-id-key\", entity.get(\"id\"))\n    helper.log_info(f\"Sent {len(entities)} events to Splunk.\")\n", "customized_options": [{"name": "limit", "value": "10"}, {"name": "alert_status", "value": "1"}], "uuid": "ee05fb6ede064f45989b93f82528d46c", "sample_count": "1454267"}, {"index": "default", "sourcetype": "reco-posture", "interval": "3600", "use_external_validation": true, "streaming_mode_xml": true, "name": "reco_posture", "title": "reco-posture", "description": "", "type": "customized", "parameters": [{"name": "status", "label": "Status", "help_string": "", "required": false, "possible_values": [{"value": "5", "label": "To Review"}, {"value": "6", "label": "Passed"}], "format_type": "dropdownlist", "default_value": "5", "placeholder": "", "type": "dropdownlist", "value": "5"}, {"name": "limit", "label": "Limit", "help_string": "", "required": false, "format_type": "text", "default_value": "1000", "placeholder": "", "type": "text", "value": "1000"}], "data_inputs_options": [{"type": "customized_var", "name": "status", "title": "Status", "description": "", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "5", "label": "To Review"}, {"value": "6", "label": "Passed"}], "format_type": "dropdownlist", "default_value": "5", "placeholder": ""}, {"type": "customized_var", "name": "limit", "title": "Limit", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "1000", "placeholder": ""}], "customized_options": [{"name": "status", "value": "5"}, {"name": "limit", "value": "1000"}], "code": "import json\nimport base64\nfrom datetime import datetime\n\n# Required configurations for Reco API\nRECO_API_TIMEOUT_IN_SECONDS = 30\nRECO_ACTIVE_ALERTS_VIEW = \"POSTURE_CHECKLIST\"\nCREATED_AT_FIELD = \"created_at\"\nFILTER_RELATIONSHIP_AND = \"AND\"\nDEMISTO_OCCURRED_FORMAT = \"%Y-%m-%dT%H:%M:%SZ\"\n\ndef validate_input(helper, definition):\n    \"\"\"Validate the input configurations.\"\"\"\n    pass\n\ndef collect_events(helper, ew):\n    \"\"\"Fetch incidents and alerts from Reco API and send them to Splunk.\"\"\"\n    max_fetch = helper.get_arg('limit')\n    status = helper.get_arg('status')\n    source = helper.get_arg('source')  # Ensure 'source' is retrieved if applicable\n    last_run = helper.get_check_point(\"last_run\") or {}\n    global_tenant_url = helper.get_global_setting(\"tenant_url\")\n    global_api_key = helper.get_global_setting(\"api_key\")\n    helper.log_info(f\"Starting collection of events from Reco with max_fetch={max_fetch}, status={status}, source={source}\")\n\n    # Convert last_run time to a datetime object if present\n    after = datetime.strptime(last_run.get(\"lastRun\", \"\"), DEMISTO_OCCURRED_FORMAT) if \"lastRun\" in last_run else None\n    if after:\n        helper.log_info(f\"Last run time: {after}\")\n\n    alerts = []  # Initialize the alerts variable to avoid UnboundLocalError\n    after = None\n\n    # Fetch alerts\n    try:\n        alerts = fetch_reco_alerts(helper, global_tenant_url, global_api_key, max_fetch, status, source, after)\n        helper.log_info(f\"Fetched {len(alerts)} alerts.\")\n        send_events(alerts, helper, ew)\n    except Exception as e:\n        helper.log_error(f\"Error fetching alerts: {e}\")\n\n    helper.save_check_point(\"last_run\", {\"lastRun\": datetime.now().strftime(DEMISTO_OCCURRED_FORMAT)})\n    helper.log_info(f\"Checkpoint updated with last run time\")\n\ndef fetch_reco_alerts(helper, tenant_url, api_key, max_fetch, status, source, after):\n    \"\"\"Retrieve alerts from Reco API and get additional details for each alert.\"\"\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    params = create_params(RECO_ACTIVE_ALERTS_VIEW, max_fetch, status, source, after)\n\n    helper.log_info(\"Sending request to Reco API for alert IDs.\")\n    response = helper.send_http_request(\n        url=f\"{tenant_url}/api/v1/policy-subsystem/alert-inbox/table\",\n        method=\"PUT\",\n        payload=json.dumps(params),\n        headers=headers,\n        timeout=RECO_API_TIMEOUT_IN_SECONDS,\n    )\n\n    alerts = parse_response(response)\n    \n    for alert in alerts:\n        alert_id = base64.b64decode(alert.get(\"alert_id\")).decode(\"utf-8\")\n        if alert_id:\n            alert[\"alert_id\"] = alert_id\n            alert[\"all_policy\"] = None\n            alert[\"instance_id\"] = base64.b64decode(alert.get(\"instance_id\")).decode(\"utf-8\")\n            \n\n    return alerts\n\ndef get_single_alert(helper, tenant_url, api_key, alert_id):\n    \"\"\"Fetch a single alert's detailed information from Reco API.\"\"\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    response = helper.send_http_request(\n        url=f\"{tenant_url}/api/v1/policy-subsystem/alert-inbox/{alert_id}\",\n        method=\"GET\",\n        headers=headers,\n        timeout=RECO_API_TIMEOUT_IN_SECONDS,\n    )\n\n    if response.status_code != 200:\n        helper.log_error(f\"Failed to retrieve alert {alert_id}, status code: {response.status_code}\")\n        return {}\n\n    alert_details = response.json().get(\"alert\", {})\n    return alert_details\n\ndef create_params(view_name, max_fetch, status, source, after):\n    \"\"\"Create request parameters for Reco API.\"\"\"\n    filters = {\"relationship\": FILTER_RELATIONSHIP_AND, \"filters\": {\"filters\": []}}\n    if status:\n        filters[\"filters\"][\"filters\"].append({\"field\": \"status\", \"stringEquals\": {\"value\": status}})\n    if source:\n        filters[\"filters\"][\"filters\"].append({\"field\": \"data_source\", \"stringEquals\": {\"value\": source}})\n    if after:\n        filters[\"filters\"][\"filters\"].append(\n            {\"field\": CREATED_AT_FIELD, \"after\": {\"value\": after.strftime(DEMISTO_OCCURRED_FORMAT)}})\n\n    return {\n        \"getTableRequest\": {\n            \"tableName\": view_name,\n            \"pageSize\": max_fetch,\n            \"fieldFilters\": filters,\n            \"fieldSorts\": {\n                \"sorts\": [{\"sortBy\": \"updated_at\", \"sortDirection\": \"SORT_DIRECTION_ASC\"}]\n            }\n        }\n    }\n\ndef parse_response(response):\n    \"\"\"Parse Reco API response.\"\"\"\n    if response.status_code != 200:\n        raise ValueError(f\"Failed to retrieve data, status code: {response.status_code}\")\n    response_data = response.json().get(\"getTableResponse\", {}).get(\"data\", {}).get(\"rows\", [])\n    return [parse_table_row_to_dict(row.get(\"cells\", [])) for row in response_data]\n\ndef parse_table_row_to_dict(alert):\n    \"\"\"Parse a row of alert data into a dictionary format.\"\"\"\n    alert_as_dict = {}\n    for obj in alert:\n        key = obj.get(\"key\")\n        value = obj.get(\"value\")\n        if key and value:\n            alert_as_dict[key] = base64.b64decode(value).decode(\"utf-8\").replace('\"', \"\")\n    return alert_as_dict\n\ndef send_events(entities, helper, ew):\n    \"\"\"Send parsed incidents or alerts as events to Splunk.\"\"\"\n    for entity in entities:\n        event = helper.new_event(data=json.dumps(entity), source=helper.get_input_type(), sourcetype=helper.get_sourcetype(), index=helper.get_output_index())\n        ew.write_event(event)\n        helper.save_check_point(\"alert-id-key\", entity.get(\"id\"))\n    helper.log_info(f\"Sent {len(entities)} events to Splunk.\")\n", "uuid": "2d39f5bd29e6409f923212aa62af1975", "sample_count": "90"}]}, "global_settings_builder": {"global_settings": {"log_settings": {"log_level": "DEBUG"}, "customized_settings": [{"required": false, "name": "tenant_url", "label": "Tenant URL", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": "https://demo.us.reco.ai"}, {"required": false, "name": "api_key", "label": "API Key", "placeholder": "", "default_value": "", "help_string": "", "type": "password", "format_type": "password", "value": ""}]}}, "sourcetype_builder": {"recoAlerts": {"metadata": {"data_input_name": "reco_alerts"}}, "reco-posture": {"metadata": {"data_input_name": "reco_posture"}}}, "validation": {}}